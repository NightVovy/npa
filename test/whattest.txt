matrix: 原版本的matrix但是换了方式输出。目前matrix3还是老问题，在找问题，应该问题出在取值区间和公式不对。

functions: 集合了一些常用功能，目前只有量子测量。

test4: 验证那个b三次多项式的解，说了很多次了这个就没有实数解。

https://colab.research.google.com/drive/1pvb7d3WbctnNwEXC5UpqOKjwhbm0jPqF#scrollTo=o91j_AZlAEAR


2024.10.21 创建一个新的matrix，验证已知beta值，在Iap上
test5from m3_2: 验证pij=1，alpha=1的时候，用NPA算最大违背【结果近似（我没说是一致啊）】简单修改alpha值也是这样。
alpha的滑块暂时用不了，1没有安装求解器2没有cvxpy

2024.10.24 在test5.3上验证：p10=p11=1, p00 , p11 不相等, 最后的结果怎么样‘
注意这里alpha^2的极限，应该是4（pij=1）。
findp 是脚本...

2024.10.28
findp2 让alpha固定为1，p10=p11=1, 遍历了p00,p01从0到1的满足lambda1和problem.value差值在e-5内的情况。
结果只有一个：p00=1,p01=0.
findp3 alpha也跟着变化，但是p10=p11=1不变。
结果：非常多，并且lambda都是4.
findp4 这次让p10=p11变化，初始值为1，步长0.05
小问题：if p00 + p01 > 1:
                    continue  # 确保 p00 + p01 <= 1
这是要干啥？
注意3和4的遍历，都没带上p01.

2024.10.29
findphard.py 让p10 != p11了，是一个超级嵌套for循环遍历，效率低也得等。
纠正：没有任何意义，因为A19不对了。
checkpq.py 想到了之前为什么要让p00 = p*q的事情，于是这个代码是用来验证上面findp的结果是否满足这个定义。
【不对】不管怎么说pij求和都不能为1.
(请忽略上面两个没用的代码）
[已经丢到垃圾桶里了]
neqez.py 由于p10neqp11.py实在是太复杂太慢，于是固定了p00,p10的取值，大步长变化另外3个变量，代入A5A13的两个方程尝试计算theta和beta。
就是看起来还是很慢。（事实上是根本运行不了）


2024.10.31
想尝试A5A13能不能得到解。。。。
trysolve.py: 自己输入pij和alpha，解出beta和theta的值。然后再带回lambda里面。
(滑块版，放在了colab)
test6from5.py: 直接把trysolve和NPA放一起看了，但是这样就没法用滑块。
